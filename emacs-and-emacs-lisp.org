#+TITLE: Journal on Emacs and Emacs Lisp

* 分别用 let/pcase-let/seq-let/-let 实现同样的需求
Entered on [2017-12-24 Sun 14:08]

#+begin_src emacs-lisp
(let* ((l (benchmark-run (sleep-for .2)))
       (total (nth 0 l))
       (gc (nth 1 l))
       (gc-total (nth 2 l)))
  (list total gc gc-total))
#+end_src

#+RESULTS:
| 0.20749 | 0 | 0.0 |

#+begin_src emacs-lisp
(pcase-let ((`(,total ,gc ,gc-total)
             (benchmark-run (sleep-for .2))))
  (list total gc gc-total))
#+end_src

#+RESULTS:
| 0.20612 | 0 | 0.0 |

#+begin_src emacs-lisp
(seq-let (total gc gc-total) (benchmark-run (sleep-for .2))
  (list total gc gc-total))
#+end_src

#+RESULTS:
| 0.203467 | 0 | 0.0 |

#+begin_src emacs-lisp
(-let (((total gc gc-total)
        (benchmark-run (sleep-for .2))))
  (list total gc gc-total))
#+end_src

#+RESULTS:
| 0.205723 | 0 | 0.0 |

* 一个简单的 [[info:elisp#Generic%20Functions][Generic Functions]] 例子
Entered on [2017-12-25 Mon 11:43]

根据参数的类型自动选择不同的方法。

#+begin_src emacs-lisp
(cl-defgeneric foo-size (x)
  "Return the size of x.")

(cl-defmethod foo-size ((s string))
  "Return the size of the string S."
  (length s))

(cl-defmethod foo-size ((b buffer))
  "Return the size of the buffer B."
  (buffer-size b))
#+end_src

#+RESULTS:
: foo-size

#+begin_src emacs-lisp
(foo-size "hello")
#+end_src

#+RESULTS:
: 5

#+begin_src emacs-lisp
(with-temp-buffer
  (insert "hello")
  (foo-size (current-buffer)))
#+end_src

#+RESULTS:
: 5

* Use =M-x ediff-regions-wordwise= to diff sexps (list)
Entered on [2017-12-27 Wed 14:52]

#+begin_example
(bar baz qux quux corge grault garply waldo fred plugh)
(bar baz qux quux corge thud grault garply waldo fred xyzzy plugh)
#+end_example

and ignore white spaces can be userful

#+begin_src emacs-lisp
(setq ediff-diff-options "-w")
#+end_src

[[https://emacs.stackexchange.com/questions/22313/sexp-diff-like-mode-for-elisp-source-diffing][Sexp-diff like mode for elisp source diffing - Emacs Stack Exchange]]

* cl-block and cl-return
Entered on [2017-12-29 Fri 21:41]

cl-block/cl-return is like catch/throw

#+begin_src emacs-lisp
(catch 'found
  1
  2
  (throw 'found 100)
  3)
#+end_src

#+RESULTS:
: 100

#+begin_src emacs-lisp
(cl-block nil
  1
  2
  (cl-return 100)
  3)
#+end_src

#+RESULTS:
: 100

cl-defun/cl-dotimes/etc implies cl-block

#+begin_src emacs-lisp
(cl-defun foo ()
  1
  2
  (cl-return-from foo 100)
  3)
(foo)
#+end_src

#+RESULTS:
: 100

#+begin_src emacs-lisp
(let (res)
  (cl-dotimes (i 10000)
    (if (< i 4)
        (push i res)
      (cl-return)))
  (nreverse res))
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 3 |

* Copy the prompt of the MiniBuffer
Entered on [2017-12-30 Sat 14:13]

Like shell/eshell/comint, find a way to move point (for example, ~C-b~
(~backward-char~)) within the prompt then mark-copy as usual.

[[https://emacs.stackexchange.com/questions/15198/how-to-copy-minibuffer-contents][echo area - How to copy minibuffer contents? - Emacs Stack Exchange]]
* Hash Table in Emacs Lisp
Entered on [2018-01-04 Thu 00:58]

** Create Hash Table

Use ~make-hash-table~

#+begin_src emacs-lisp
(make-hash-table :test #'equal)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data ())

Use the printed representation

#+begin_src emacs-lisp
#s(hash-table test equal data (:one 1 :two 2))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8125 data (:one 1 :two 2))

** Access Hash Table

Add and lookup

#+begin_src emacs-lisp
(let ((hash (make-hash-table :test #'eq)))
  (puthash :one 1 hash)
  (puthash :two 2 hash)
  (list :one (gethash :one hash)
        :two (gethash :two hash)))
#+end_src

#+RESULTS:
| :one | 1 | :two | 2 |

Remove

#+begin_src emacs-lisp
(let ((hash #s(hash-table test eq data (:one 1 :two 2))))
  (remhash :one hash)
  hash)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data ( :two 2))

Clear (remove all)

#+begin_src emacs-lisp
(let ((hash #s(hash-table test eq data (:one 1 :two 2))))
  (clrhash hash)
  hash)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eq rehash-size 1.5 rehash-threshold 0.8125 data ())

Lookup all

#+begin_src emacs-lisp
(let (alist)
  (maphash
   (lambda (key value)
     (push (cons key value) alist))
   #s(hash-table data (:one 1 :two 2)))
  alist)
#+end_src

#+RESULTS:
: ((:two . 2) (:one . 1))

Count

#+begin_src emacs-lisp
(hash-table-count #s(hash-table data (a 1 b 2)))
#+end_src

#+RESULTS:
: 2

Keys & Values (hash-table-keys and hash-table-values is defined by subr-x.el)

#+begin_src emacs-lisp
(hash-table-keys #s(hash-table data (one 1 two 2 three 3)))
#+end_src

#+RESULTS:
| one | two | three |

#+begin_src emacs-lisp
(hash-table-values #s(hash-table data (one 1 two 2 three 3)))
#+end_src

#+RESULTS:
| 1 | 2 | 3 |

Performance (vs Alist)

#+begin_src emacs-lisp
(let ((alist nil)
      (hash (make-hash-table :test #'eq)))
  (mapatoms
   (lambda (symbol)
     (let ((key symbol)
           (val (length (symbol-name symbol))))
       (push (cons key val) alist)
       (puthash key val hash))))
  (let ((t1 (car (benchmark-run 1000 (assq 'length alist))))
        (t2 (car (benchmark-run 1000 (gethash 'length hash)))))
    (message "Alist takes %.5fs, Hash Table takes %.5fs" t1 t2)))
#+end_src

#+RESULTS:
: Alist takes 1.97789s, Hash Table takes 0.00017s
