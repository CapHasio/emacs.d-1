#+TITLE: The Scheme Programming Language
#+DATE: <2020-01-09 Thu>

#+PROPERTY: header-args:scheme :results scalar

* Exercise
** 2.2.1

#+begin_src scheme :scheme chez
(+ (* 1.2 (- 2 1/3)) -8.7)
#+end_src

#+RESULTS:
: -6.699999999999999

#+begin_src scheme
(/ (+ (/ 2 3) (/ 4 9)) (- (/ 5 11) (/ 4 3)))
#+end_src

#+RESULTS:
: -110/87

#+begin_src scheme
(+ 1 (/ 1 (+ 2 (/ 1 (+ 1 (/ 1 2))))))
#+end_src

#+RESULTS:
: 11/8

#+begin_src scheme
(* 1 (* -2 (* 3 (* -4 (* 5 (* -6 7))))))
#+end_src

#+RESULTS:
: -5040

** 2.2.2

#+begin_src scheme
(+ 1 2.0)
#+end_src

#+RESULTS:
: 3.0

#+begin_src scheme
(- 1 1.0)
#+end_src

#+RESULTS:
: 0.0

#+begin_src scheme
(+ 1/3 2/3)
#+end_src

#+RESULTS:
: 1

#+begin_src scheme
(* 1.0 0)
#+end_src

#+RESULTS:
: 0.0

#+begin_src scheme
(/ 0 1)
#+end_src

#+RESULTS:
: 0

#+begin_src scheme
(/ 1 3)
#+end_src

#+RESULTS:
: 1/3

** 2.2.3

#+NAME: my_answers_2.2.3
- (car . cdr)
- (this (is silly))
- (is this silly?)
- (+ 2 3)
- (+ 2 3)
- +
- (2 3)
- procedure cons
- cons
- (quote cons)
- quote
- 5
- 5
- 5
- 5

#+begin_src scheme :scheme chez
(list
 (cons 'car 'cdr)   
 (list 'this '(is silly))   
 (cons 'is '(this silly?))   
 (quote (+ 2 3))   
 (cons '+ '(2 3))   
 (car '(+ 2 3))   
 (cdr '(+ 2 3))   
 cons   
 (quote cons)   
 (quote (quote cons))   
 (car (quote (quote cons)))   
 (+ 2 3)   
 (+ '2 '3)   
 (+ (car '(2 3)) (car (cdr '(2 3))))   
 ((car (list + - * /)) 2 3))
#+end_src

#+RESULTS:
: ((car . cdr) (this (is silly)) (is this silly?) (+ 2 3)
:   (+ 2 3) + (2 3) #<procedure cons> cons 'cons quote 5 5 5 5)

** 2.2.4

#+begin_src scheme
(car (cdr (car '((a b) (c d)))))
#+end_src

#+RESULTS:
: b

#+begin_src scheme
(car (car (cdr '((a b) (c d)))))
#+end_src

#+RESULTS:
: c

#+begin_src scheme
(car (cdr (car (cdr '((a b) (c d))))))
#+end_src

#+RESULTS:
: d

** 2.2.5

#+begin_src scheme :results scalar
(cons (cons 'a 'b) (cons (cons (cons 'c '()) (cons 'd '())) (cons '() '())))
#+end_src

#+RESULTS:
: ((a . b) ((c) d) ())

** 2.2.6

#+begin_src scheme :results scalar
(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))
#+end_src

#+RESULTS:
: (1 (2 (3)) (()) 4 . 5)

** 2.2.7

#+begin_src scheme
(let ((l '((a b) (c d))))
  (list
   (car l)
   (car (car l))
   (cdr (car l))
   (car (cdr (car l)))
   (cdr (cdr (car l)))

   #:cdr

   (cdr l)
   (cdr (cdr l))
   (car (cdr l))
   (car (car (cdr l)))
   (cdr (car (cdr l)))
   (car (cdr (car (cdr l))))
   (cdr (cdr (car (cdr l))))
   ))
#+end_src

#+RESULTS:
: ((a b) a (b) b () #:cdr ((c d)) () (c d) c (d) d ())

** 2.2.8

(+ 1 2)
((car '(+ - * /)) 1 2 (* 3 4))

(e0 e1 e2...)

** 2.3.1

((car (cdr (list + - * /))) 17 5)

1. (list + - * /) => (+ - * /)
2. (cdr (list + - * /)) => (- * /)
3. (car '(- * /)) => -
4. (- 17 5) => 12

** 2.4.1

#+begin_src scheme
(let ([a 1]
      [b 2])
  (list
   #:want
   (+ (- (* 3 a) b) (+ (* 3 a) b))
   #:get
   (let ([x (* 3 a)])
     (+ (- x b) (+ x b)))))
#+end_src

#+RESULTS:
: (#:want 6 #:get 6)

#+begin_src scheme
(cons (car (list a b c))
      (cdr (list a b c)))

(let ((lst (list a b c)))
  (cons (car lst) (cdr lst)))
#+end_src

** 2.4.2

54

#+begin_src scheme
(let ([x 9])
  (* x
     (let ([x (/ x 3)])
       (+ x x))))
#+end_src

#+RESULTS:
: 54

** 2.4.3

#+begin_src scheme
(let ([x 'a] [y 'b])
  (list (let ([x 'c]) (cons x y))
        (let ([y 'd]) (cons x y))))
#+end_src

#+RESULTS:
: ((c . b) (a . d))

#+begin_src scheme
(let ([x 'a] [y 'b])
  (list (let ([new-x 'c]) (cons new-x y))
        (let ([new-y 'd]) (cons x new-y))))
#+end_src

#+RESULTS:
: ((c . b) (a . d))

#+begin_src scheme
(let ([x '((a b) c)])
  (cons (let ([x (cdr x)])              ; x => (c)
          (car x))                      ; c
        (let ([x (car x)])              ; x => (a b)
          (cons (let ([x (cdr x)])      ; x => (b)
                  (car x))              ; b
                (cons (let ([x (car x)]) ; x => a
                        x)               ; a
                      (cdr x))))))       ; (b)

;; (cons 'c (cons 'b (cons 'a '(b))))
;; =>
;; (c b a b)

#+end_src

#+RESULTS:
: (c b a b)

#+begin_src scheme
(let ([x '((a b) c)])
  (cons (let ([x1 (cdr x)])
          (car x1))
        (let ([x2 (car x)])
          (cons (let ([x3 (cdr x2)])
                  (car x3))
                (cons (let ([x4 (car x2)])
                        x4)
                      (cdr x2))))))
#+end_src

#+RESULTS:
: (c b a b)

** 2.5.1

#+begin_src scheme
(let ([f (lambda (x) x)])
  (f 'a))
;; a

(let ([f (lambda x x)])
  (f 'a))
;; (a)

(let ([f (lambda (x . y) x)])
  (f 'a))
;; a

(let ([f (lambda (x . y) y)])
  (f 'a))
;; ()
#+end_src

** 2.5.2

#+begin_src scheme
(let ([list (lambda x x)])
  (list
   (list)
   (list (list 1) 2 3 '(4 5))
   (list 1 2 3)))
#+end_src

#+RESULTS:
: (() ((1) 2 3 (4 5)) (1 2 3))

** 2.5.3

#+begin_src scheme
(lambda (f x) (f x)) ;; none

(lambda (x) (+ x x)) ;; +

(lambda (x y) (f x y)) ;; f

(lambda (x) 
  (cons x (f x y))) ;; f y

(lambda (x)
  (let ([z (cons x y)])
    (x y z))) ;; y

(lambda (x)
  (let ([y (cons x y)])
    (x y z))) ;; y z
#+end_src

** 2.6.1

#+BEGIN_SRC scheme
(define doubler
  (lambda (f)
    (lambda (x) (f x x))))

((doubler +) 1)

;; (define double-any
;;   (lambda (f x)
;;     ((doubler f) x)))

;; (double-any + 2)

;; double-any 就是 (lambda (f x) (f x x))
#+END_SRC

#+RESULTS:
: 4

#+BEGIN_SRC scheme
(double-any double-any double-any)

;; =>
(double-any double-any double-any)

;; =>
(double-any double-any double-any)

;; 死循环
#+END_SRC

** 2.6.2

#+BEGIN_SRC scheme :session *compose*
(define compose
  (lambda (f g)
    (lambda (x)
      (f (g x)))))

(define my-cadr (compose car cdr))
(define my-cddr (compose cdr cdr))

(list (my-cadr '(a b c))
      (my-cddr '(a b c)))
#+END_SRC

#+RESULTS:
: (b (c))

** 2.6.3

#+BEGIN_SRC scheme :session *compose*
(let ([caar (compose car car)]
      [cadr (compose car cdr)]
      [cdar (compose cdr car)]
      [cddr (compose cdr cdr)]
      [l    '((1 2) (3 4))])
  (list (caar l) 1
        (cadr l) '(3 4)
        (cdar l) '(2)
        (cddr l) '()
        ))
#+END_SRC

#+RESULTS:
: (1 1 (3 4) (3 4) (2) (2) () ())

#+BEGIN_SRC scheme :session *compose*
(let ([caaar (compose car (compose car car))]
      [cdaar (compose (compose cdr car) car)]
      [cadar (compose (compose car cdr) car)]
      [l    '(((1 2) (3 4)) ((5 6) (7 8)))])
  (list (caaar l) 1
        (cdaar l) '(2)
        (cadar l) '(3 4)))
#+END_SRC

#+RESULTS:
: (1 1 (2) (2) (3 4) (3 4))

#+BEGIN_SRC scheme :session *compose*
(let ([caadar (compose car (compose car (compose cdr car)))])
  (caddar '((1 2 3))))
#+END_SRC

#+RESULTS:
: 3

** 2.7.1

#+begin_src scheme
(define atom?
  (lambda (x)
    (not (pair? x))))

(map atom? '(1 () (2 3) "hello" a 2.3))
#+end_src

#+RESULTS:
: (#t #t #f #t #t #t)

** 2.7.2

#+begin_src scheme
(define shorter 
  (lambda (lst1 lst2)
    (if (<= (length lst1)
            (length lst2))
        lst1
        lst2)))

(shorter '(a b) '(c d e))
#+end_src

#+RESULTS:
: (a b)

#+begin_src scheme
(use-modules (rnrs base))               ; error

(define shorter 
  (lambda (lst1 lst2)
    (cond
     [(not (and (list? lst1) (list? lst2)))
      (assertion-violation
       'shorter
       "improper argument"
       lst1 lst2)]
     [(<= (length lst1) (length lst2))
      lst1])))

(shorter '(a b) '(c d e)) 
(shorter '(a b) '(c d)) 
(shorter '(a b) '(c))
;; (shorter 12 '(c))
#+end_src

#+RESULTS:
: #<unspecified>

** 2.8.1

#+begin_src scheme
(define tree-copy
  (lambda (tr)
    (if (not (pair? tr))
        tr
        (cons (tree-copy (car tr))
              (tree-copy (cdr tr))))))

(tree-copy '((a . b) . (c . d)))
#+end_src

#+RESULTS:
: ((a . b) c . d)

#+begin_src scheme :scheme chez
(define tree-copy
  (lambda (tr)
    (if (not (pair? tr))
        tr
        (cons (tree-copy (cdr tr))
              (tree-copy (car tr))))))

(tree-copy '((a . b) . (c . (d . g))))
#+end_src

#+RESULTS:
: (((g . d) . c) b . a)

tree 所有 pair 的 car 和 cdr 都会相互交换

** 2.8.2

#+begin_src scheme
(append '(a b) '(c d e))
#+end_src

#+RESULTS:
: (a b c d e)

#+begin_src scheme
(define append 
  (lambda (ls1 ls2)
    (if (null? ls1)
        ls2
        (cons (car ls1) (append (cdr ls1) ls2)))))

(append '(1 2 3) '(4 5))
#+end_src

#+RESULTS:
: (1 2 3 4 5)

应该会返回 (3 2 1 4 5)

#+begin_src scheme
(define append 
  (lambda (ls1 ls2)
    (if (null? ls1)
        ls2
        (append (cdr ls1) (cons (car ls1) ls2)))))

(append '(1 2 3) '(4 5))
#+end_src

#+RESULTS:
: (3 2 1 4 5)

** 2.8.3

#+begin_src scheme
(define make-list
  (lambda (n x)
    (if (= n 0)
        '()
        (cons x (make-list (1- n) x)))))

(make-list 7 '())
#+end_src

#+RESULTS:
: (() () () () () () ())

** 2.8.4

#+begin_src scheme
(define list-ref
  (lambda (ls n)
    (if (zero? n)
        (car ls)
        (list-ref (cdr ls) (1- n)))))


(list-ref '(1 2 3 4) 0) 
;; => 1

;; 1

(list-ref '(a short (nested) list) 2) 
;; => (nested)

;; (nested)
#+end_src

#+begin_src scheme
(define list-tail
  (lambda (ls n)
    (if (zero? n)
        ls
        (list-tail (cdr ls) (1- n)))))

(list-tail '(1 2 3 4) 0)
;; => (1 2 3 4)

(list-tail '(a short (nested) list) 2) 
;; => ((nested) list)


#+end_src

** 2.8.5

#+begin_src scheme
(define shorter?
  (lambda (ls1 ls2)
    (cond
     [(null? ls1) #t]
     [(null? ls2) #f]
     [else (shorter? (cdr ls1) (cdr ls2))])))

(define shorter
  (lambda (ls1 ls2)
    (if (shorter? ls1 ls2)
        ls1
        ls2)))

(shorter '(a b) '(c d e))
;; (shorter '(a b 1 2) '(c d e))
#+end_src

#+RESULTS:
: (c d e)

** 2.8.6

#+begin_src scheme
(define even?
  (lambda (n)
    (if (zero? n)
        #t
        (odd? (1- n)))))

(define odd?
  (lambda (n)
    (if (zero? n)
        #f
        (even? (1- n)))))

(even? 17)
;; => #f
 
(odd? 17)
;; => #t
#+end_src

** 2.8.7

#+begin_src scheme
(define transpose
  (lambda (ls)
    (cons (map car ls)
          (map cdr ls))))
;; => #<unspecified>

(map car '((a . 1) (b . 2) (c . 3)))
;; => (a b c)

(map cdr '((a . 1) (b . 2) (c . 3)))
;; => (1 2 3)

(transpose '((a . 1) (b . 2) (c . 3)))
;; => ((a b c) 1 2 3)
;; ((a b c) . (1 2 3))
#+end_src
