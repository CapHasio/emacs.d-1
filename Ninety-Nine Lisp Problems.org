#+PROPERTY: header-args:emacs-lisp :lexical yes :results value verbatim

* L-99: Ninety-Nine Lisp Problems

  #+NAME: progress
  | Total | Done | Doing | Left |
  |-------+------+-------+------|
  |    99 |   22 |     1 |   76 |
  #+TBLFM: $1=99::$2='(count-matches (rx line-start "*** "))::$3='(count-matches (rx line-start "*** TODO"))::$4=$1-$2-$3

** Working with lists

*** Find the last box of a list

    #+BEGIN_EXAMPLE
      (my-last '(a b c d)) => (d)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-last (list)
        (if (cdr list)
            (my-last (cdr list))
          list))

      (my-last '(a b c d))
    #+END_SRC

    #+RESULTS:
    : (d)

*** Find the last but one box of a list

    #+BEGIN_EXAMPLE
      (my-but-last '(a b c d)) => (c d)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-but-last (l)
        (let ((len (length l)))
          (if (<= len 2)
              l
            (list (nth (- len 2) l)
                  (nth (- len 1) l)))))

      (my-but-last '(a b c d))
    #+END_SRC

    #+RESULTS:
    : (c d)

*** Find the K'th element of a list

    #+BEGIN_EXAMPLE
    (element-at '(a b c d e) 3) => c
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-element-at (lst idx)
        (if (= idx 1)
            (car lst)
          (my-element-at (cdr lst) (- idx 1))))

      (my-element-at '(a b c d e) 3)
    #+END_SRC

    #+RESULTS:
    : c

*** Find the number of elements of a list

    #+BEGIN_SRC emacs-lisp
      (defun my-length (lst)
        (if (null lst)
            0
          (+ 1 (my-length (cdr lst)))))

      (list (my-length '())
            (my-length '(a b c)))
    #+END_SRC

    #+RESULTS:
    : (0 3)

*** Reverse a list

    #+BEGIN_SRC emacs-lisp
      (defun my-reverse (lst)
        (if (null lst)
            nil
          (append (my-reverse (cdr lst)) (list (car lst)))))

      (my-reverse '(1 2 3 4))
    #+END_SRC

    #+RESULTS:
    : (4 3 2 1)

*** Find out whether a list is a palindrome

    A palindrome can be read forward or backward

    #+BEGIN_EXAMPLE
    (x a m a x).
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-palindrome (lst)
        (equal (reverse lst) lst))

      (my-palindrome '(x a m a x))
    #+END_SRC

    #+RESULTS:
    : t

*** Flatten a nested list structure

    Transform a list, possibly holding lists as elements into a `flat' list by
    replacing each list with its elements (recursively).

    #+BEGIN_EXAMPLE
      (my-flatten '(a (b (c d) e))) => (A B C D E)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-flatten (lst)
        (if (null lst)
            nil
          (let ((head (car lst))
                (rest (cdr lst)))
            (if (consp head)
                (append (my-flatten head) (my-flatten rest))
              (cons head (my-flatten rest))))))

      (my-flatten '(a (b (c d) e)))
    #+END_SRC

    #+RESULTS:
    : (a b c d e)

*** Eliminate consecutive duplicates of list elements

    If a list contains repeated elements they should be replaced with a single
    copy of the element. The order of the elements should not be changed.

    #+BEGIN_EXAMPLE
    (compress '(a a a a b c c a a d e e e e)) => (a b c a d e)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun compress (lst)
        (let (result last)
          (dolist (i lst result)
            (if (null result)
                (setq result (list i))
              (unless (eq i last)
                (setq result (append result (list i)))))
            (setq last i))))

      (compress '(a a a a b c c a a d e e e e))
    #+END_SRC

    #+RESULTS:
    : (a b c a d e)

*** Pack consecutive duplicates of list elements into sublists

    If a list contains repeated elements they should be placed in separate
    sublists.

    #+BEGIN_EXAMPLE
      (pack '(a a a a b c c a a d e e e e))
      =>
      ((a a a a) (b) (c c) (a a) (d) (e e e e))
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-pack (l)
        (let (last res)
          (dolist (i l (nreverse res))
            (if (null res)
                (push (list i) res)
              (if (eq i last)
                  (setcar res (push i (car res)))
                (push (list i) res)))
            (setq last i))))

      (my-pack '(a a a a b c c a a d e e e e))
    #+END_SRC

    #+RESULTS:
    : ((a a a a) (b) (c c) (a a) (d) (e e e e))

*** Run-length encoding of a list

    Use the result of problem P09 to implement the so-called run-length encoding
    data compression method. Consecutive duplicates of elements are encoded as
    lists (N E) where N is the number of duplicates of the element E.

    #+BEGIN_EXAMPLE
    (encode '(a a a a b c c a a d e e e e))
    =>
    ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e))
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-encode (l)
        (let (res)
          (dolist (i (my-pack l) (nreverse res))
            (push (list (length i) (car i)) res))))

      (my-encode '(a a a a b c c a a d e e e e))
    #+END_SRC

    #+RESULTS:
    : ((4 a) (1 b) (2 c) (2 a) (1 d) (4 e))

*** Modified run-length encoding

    Modify the result of problem P10 in such a way that if an element has no
    duplicates it is simply copied into the result list. Only elements with
    duplicates are transferred as (N E) lists.

    #+BEGIN_EXAMPLE
    (encode-modified '(a a a a b c c a a d e e e e))
    =>
    ((4 A) B (2 C) (2 A) D (4 E))
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-encode-modified (l)
        (let (res)
          (dolist (i (my-pack l) (nreverse res))
            (push (if (cdr i)
                      (list (length i) (car i))
                    (car i))
                  res))))

      (my-encode-modified '(a a a a b c c a a d e e e e))
    #+END_SRC

    #+RESULTS:
    : ((4 a) b (2 c) (2 a) d (4 e))

*** Decode a run-length encoded list

    Given a run-length code list generated as specified in problem
    P11. Construct its uncompressed version.

    #+BEGIN_SRC emacs-lisp
      (defun my-decode-modified (l)
        (let (res)
          (dolist (i l res)
            (setq res (append res
                              (if (consp i)
                                  (make-list (car i) (cadr i))
                                (list i)))))))

      (my-decode-modified (my-encode-modified '(a a a a b c c a a d e e e e)))
    #+END_SRC

    #+RESULTS:
    : (a a a a b c c a a d e e e e)

*** TODO Run-length encoding of a list (direct solution)

    Implement the so-called run-length encoding data compression method
    directly. I.e.  don't explicitly create the sublists containing the
    duplicates, as in problem P09, but only count them. As in problem P11,
    simplify the result list by replacing the singleton lists (1 X) by X.

    #+BEGIN_EXAMPLE
      Example:
      (encode-direct '(a a a a b c c a a d e e e e))
      ((4 A) B (2 C) (2 A) D (4 E))
    #+END_EXAMPLE

*** Duplicate the elements of a list

    #+BEGIN_EXAMPLE
      Example:
      (dupli '(a b c c d))
      (A A B B C C C C D D)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-dupli (l)
        (let (res)
          (dolist (i l (nreverse res))
            (push i res)
            (push i res))))

      (my-dupli '(a b c c d))
    #+END_SRC

    #+RESULTS:
    : (a a b b c c c c d d)

*** Replicate the elements of a list a given number of times

    #+BEGIN_EXAMPLE
      (repli '(a b c) 3)
      (A A A B B B C C C)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-repli (l n)
        (loop for i in l
              append (make-list n i)))

      (my-repli '(a b c) 3)
    #+END_SRC

    #+RESULTS:
    : (a a a b b b c c c)

*** Drop every N'th element from a list

    #+BEGIN_EXAMPLE
      (drop '(a b c d e f g h i k) 3)
      (A B D E G H K)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-drop (l n)
        (loop for elt in l
              for idx from 1
              unless (zerop (% idx n))
              collect elt))

      (my-drop '(a b c d e f g h i k) 3)
    #+END_SRC

    #+RESULTS:
    : (a b d e g h k)

*** Split a list into two parts; the length of the first part is given

    Do not use any predefined predicates.

    #+BEGIN_EXAMPLE
    (split '(a b c d e f g h i k) 3)
    ((A B C) (D E F G H I K))
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-split (l n)
        (loop with head = nil
              with tail = nil
              for idx from 1
              for i in l
              if (<= idx n)
              do (push i head)
              else
              do (push i tail)
              finally return (list (nreverse head) (nreverse tail))))

      (my-split '(a b c d e f g h i k) 3)
    #+END_SRC

    #+RESULTS:
    : ((a b c) (d e f g h i k))

*** Extract a slice from a list

    Given two indices, I and K, the slice is the list containing the elements
    between the I'th and K'th element of the original list (both limits
    included). Start counting the elements with 1.

    #+BEGIN_EXAMPLE
    (slice '(a b c d e f g h i k) 3 7)
    (c d e f g)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-slice (l from to)
        (loop for idx from 1
              for i in l
              when (<= from idx to)
              collect i))

      (my-slice '(a b c d e f g h i k) 3 7)
    #+END_SRC

    #+RESULTS:
    : (c d e f g)

*** Rotate a list N places to the left

    #+BEGIN_EXAMPLE
      (rotate '(a b c d e f g h) 3)
      (D E F G H A B C)

      (rotate '(a b c d e f g h) -2)
      (G H A B C D E F)
    #+END_EXAMPLE

    Hint: Use the predefined functions length and append, as well as the result
    of problem P17.

    #+BEGIN_SRC emacs-lisp
      (defun my-rotate (l n)
        (when (< n 0)
          (setq n (+ n (length l))))
        (let ((res (my-split l n)))
          (append (cadr res) (car res))))

      (my-rotate '(a b c d e f g h) 3)
      (my-rotate '(a b c d e f g h) -2)
    #+END_SRC

    #+RESULTS:
    : (g h a b c d e f)

*** Remove the K'th element from a list

    #+BEGIN_EXAMPLE
    (remove-at '(a b c d) 2)
    (a c d)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-remove-at (l n)
        (if (null l)
            nil
          (if (= n 0)
              (my-remove-at (cdr l) (1- n))
            (cons (car l) (my-remove-at (cdr l) (1- n))))))

      (my-remove-at '(a b c d) 2)
    #+END_SRC

    #+RESULTS:
    : (a b d)

*** Insert an element at a given position into a list

    #+BEGIN_EXAMPLE
    (insert-at 'alfa '(a b c d) 2)
    (A ALFA B C D)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-insert-at (item l idx)
        (if (null l)
            nil
          (if (= idx 1)
              (cons item
                    (cons (car l)
                          (my-insert-at item (cdr l) (- idx 1))))
            (cons (car l)
                  (my-insert-at item (cdr l) (- idx 1))))))

      (my-insert-at 'alfa '(a b c d) 2)
    #+END_SRC

    #+RESULTS:
    : (a alfa b c d)

*** Create a list containing all integers within a given range

    If first argument is smaller than second, produce a list in decreasing
    order.

    #+BEGIN_EXAMPLE
      (range 4 9)
      (4 5 6 7 8 9)
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (defun my-range (from to)
        (if (> from to)
            nil
          (cons from (my-range (1+ from) to))))

      (my-range 4 9)
    #+END_SRC

    #+RESULTS:
    : (4 5 6 7 8 9)
